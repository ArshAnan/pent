import { NextRequest, NextResponse } from 'next/server';
import { Daytona } from '@daytonaio/sdk';
import { 
  analyzeCodeStatic, 
  analyzeExecutionOutput, 
  calculateRiskLevel 
} from '@/lib/vulnerability-checks';
import { 
  MultiFilePenTestRequest, 
  MultiFilePenTestResponse, 
  FileAnalysisResult,
  Vulnerability 
} from '@/lib/types';

export async function POST(request: NextRequest) {
  try {
    const body: MultiFilePenTestRequest = await request.json();
    const { files, testType = 'both' } = body;

    if (!files || files.length === 0) {
      return NextResponse.json(
        { error: 'No files provided' },
        { status: 400 }
      );
    }

    // Validate environment variables
    const daytonaApiKey = process.env.DAYTONA_API_KEY;
    const daytonaApiUrl = process.env.DAYTONA_API_URL;

    if (!daytonaApiKey) {
      return NextResponse.json(
        { error: 'DAYTONA_API_KEY not configured' },
        { status: 500 }
      );
    }

    const results: FileAnalysisResult[] = [];
    let sandboxId = '';
    let daytona: Daytona | null = null;
    let sandbox: any = null;

    try {
      // For dynamic analysis, create a single sandbox for all files
      if (testType === 'dynamic' || testType === 'both') {
        console.log('Creating Daytona sandbox for multi-file analysis...');
        daytona = new Daytona({
          apiKey: daytonaApiKey,
          apiUrl: daytonaApiUrl || 'https://app.daytona.io/api'
        });

        sandbox = await daytona.create();
        sandboxId = sandbox.id;
        console.log(`Sandbox created: ${sandboxId}`);
      }

      // Analyze each file
      for (const file of files) {
        if (file.language === 'unknown') {
          continue;
        }

        let fileVulnerabilities: Vulnerability[] = [];
        let executionOutput = '';
        let executionError = '';

        // Static Analysis
        if (testType === 'static' || testType === 'both') {
          const staticVulns = analyzeCodeStatic(file.content);
          fileVulnerabilities.push(...staticVulns);
        }

        // Dynamic Analysis
        if ((testType === 'dynamic' || testType === 'both') && sandbox) {
          try {
            const languageConfig = getLanguageConfig(file.language);
            const basename = file.filename.split('/').pop() || file.filename;
            const targetFilename = `${Date.now()}_${basename}`;

            // Upload the file to the sandbox
            console.log(`Uploading ${file.filename} to sandbox...`);
            await sandbox.fs.uploadFile(
              Buffer.from(file.content),
              `/home/daytona/${targetFilename}`
            );

            // Execute the file
            console.log(`Executing ${file.filename} in sandbox...`);
            const result = await sandbox.process.executeCommand(
              languageConfig.command.replace('{file}', targetFilename),
              '/home/daytona'
            );

            executionOutput = result.result || '';
            executionError = result.exitCode !== 0 ? `Process exited with code ${result.exitCode}` : '';

            // Analyze execution output
            const runtimeVulns = analyzeExecutionOutput(executionOutput, executionError);
            fileVulnerabilities.push(...runtimeVulns);

            if (result.exitCode !== 0 && result.exitCode !== null) {
              fileVulnerabilities.push({
                type: 'Execution Error',
                severity: 'medium',
                description: `Code exited with non-zero status (${result.exitCode}). This may indicate errors or security issues.`,
                location: 'Runtime'
              });
            }

          } catch (execError) {
            console.error(`Execution error for ${file.filename}:`, execError);
            executionError = execError instanceof Error ? execError.message : String(execError);
            
            fileVulnerabilities.push({
              type: 'Execution Failed',
              severity: 'medium',
              description: 'Failed to execute file in sandbox. This may indicate syntax errors or runtime issues.',
              location: 'Runtime'
            });
          }
        }

        // Calculate risk level for this file
        const riskLevel = calculateRiskLevel(fileVulnerabilities);

        results.push({
          filename: file.filename,
          language: file.language,
          report: {
            vulnerabilities: fileVulnerabilities,
            riskLevel,
            executionOutput: executionOutput || undefined,
            executionError: executionError || undefined
          },
          suggestions: [] // Will be filled by suggest-fixes-multi endpoint
        });
      }

      // Clean up sandbox
      if (sandbox && daytona) {
        console.log('Cleaning up sandbox...');
        // Try sandbox.delete() first, then try daytona.delete() with sandbox object, then with ID
        if (typeof sandbox.delete === 'function') {
          await sandbox.delete();
        } else if (typeof daytona.delete === 'function') {
          try {
            await daytona.delete(sandbox);
          } catch (e) {
            await daytona.delete(sandbox.id);
          }
        }
      }

    } catch (sandboxError) {
      console.error('Sandbox error:', sandboxError);
      
      // Try to clean up on error
      if (sandbox && daytona) {
        try {
          // Try sandbox.delete() first, then try daytona.delete() with sandbox object, then with ID
          if (typeof sandbox.delete === 'function') {
            await sandbox.delete();
          } else if (typeof daytona.delete === 'function') {
            try {
              await daytona.delete(sandbox);
            } catch (e) {
              await daytona.delete(sandbox.id);
            }
          }
        } catch (cleanupError) {
          console.error('Error cleaning up sandbox:', cleanupError);
        }
      }

      throw sandboxError;
    }

    // Calculate overall statistics
    const allVulnerabilities = results.flatMap(r => r.report.vulnerabilities);
    const overallRiskLevel = calculateRiskLevel(allVulnerabilities);

    const response: MultiFilePenTestResponse = {
      files: results,
      overallRiskLevel,
      totalVulnerabilities: allVulnerabilities.length,
      sandboxId: sandboxId || undefined,
      timestamp: new Date().toISOString()
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Multi-file pentest error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to perform multi-file security analysis',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

function getLanguageConfig(language: string): { extension: string; command: string } {
  const configs: Record<string, { extension: string; command: string }> = {
    python: { extension: 'py', command: 'python3 {file}' },
    javascript: { extension: 'js', command: 'node {file}' },
    typescript: { extension: 'ts', command: 'npx ts-node {file}' },
    bash: { extension: 'sh', command: 'bash {file}' },
    go: { extension: 'go', command: 'go run {file}' },
    java: { extension: 'java', command: 'java {file}' }
  };

  return configs[language] || configs.python;
}

