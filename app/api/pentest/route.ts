import { NextRequest, NextResponse } from 'next/server';
import { Daytona } from '@daytonaio/sdk';
import { 
  analyzeCodeStatic, 
  analyzeExecutionOutput, 
  calculateRiskLevel 
} from '@/lib/vulnerability-checks';
import { PenTestRequest, PenTestResponse, Vulnerability } from '@/lib/types';

export async function POST(request: NextRequest) {
  try {
    const body: PenTestRequest = await request.json();
    const { code, language, testType = 'both' } = body;

    if (!code || !language) {
      return NextResponse.json(
        { error: 'Code and language are required' },
        { status: 400 }
      );
    }

    // Validate environment variables
    const daytonaApiKey = process.env.DAYTONA_API_KEY;
    const daytonaApiUrl = process.env.DAYTONA_API_URL;

    if (!daytonaApiKey) {
      return NextResponse.json(
        { error: 'DAYTONA_API_KEY not configured' },
        { status: 500 }
      );
    }

    let vulnerabilities: Vulnerability[] = [];
    let executionOutput = '';
    let executionError = '';
    let sandboxId = '';

    // Static Analysis
    if (testType === 'static' || testType === 'both') {
      const staticVulns = analyzeCodeStatic(code);
      vulnerabilities.push(...staticVulns);
    }

    // Dynamic Analysis - Execute in Daytona Sandbox
    if (testType === 'dynamic' || testType === 'both') {
      try {
        const daytona = new Daytona({
          apiKey: daytonaApiKey,
          apiUrl: daytonaApiUrl || 'https://app.daytona.io/api'
        });

        // Create a sandbox
        console.log('Creating Daytona sandbox...');
        const sandbox = await daytona.create();
        sandboxId = sandbox.id;

        // Determine file extension and command based on language
        const languageConfig = getLanguageConfig(language);
        const fileName = `test.${languageConfig.extension}`;

        // Upload the code file to the sandbox
        console.log('Uploading code to sandbox...');
        await sandbox.fs.uploadFile(
          Buffer.from(code),
          `/home/daytona/${fileName}`
        );

        // Execute the code in the sandbox
        console.log('Executing code in sandbox...');
        const result = await sandbox.process.executeCommand(
          languageConfig.command.replace('{file}', fileName),
          '/home/daytona'
        );

        executionOutput = result.result || '';
        executionError = result.exitCode !== 0 ? `Process exited with code ${result.exitCode}` : '';

        // Analyze execution output for vulnerabilities
        const runtimeVulns = analyzeExecutionOutput(executionOutput, executionError);
        vulnerabilities.push(...runtimeVulns);

        // Check for dangerous behaviors during execution
        if (result.exitCode !== 0 && result.exitCode !== null) {
          vulnerabilities.push({
            type: 'Execution Error',
            severity: 'medium',
            description: `Code exited with non-zero status (${result.exitCode}). This may indicate errors or security issues.`,
            location: 'Runtime'
          });
        }

        // Clean up - delete the sandbox
        console.log('Cleaning up sandbox...');
        // Try sandbox.delete() first, then try daytona.delete() with sandbox object, then with ID
        if (typeof sandbox.delete === 'function') {
          await sandbox.delete();
        } else if (typeof daytona.delete === 'function') {
          try {
            await daytona.delete(sandbox);
          } catch (e) {
            await daytona.delete(sandbox.id);
          }
        }

      } catch (sandboxError) {
        console.error('Sandbox execution error:', sandboxError);
        executionError = sandboxError instanceof Error ? sandboxError.message : String(sandboxError);
        
        vulnerabilities.push({
          type: 'Sandbox Execution Failed',
          severity: 'high',
          description: 'Failed to execute code in isolated environment. This may indicate severe issues with the code.',
          location: 'Runtime'
        });
      }
    }

    // Calculate overall risk level
    const riskLevel = calculateRiskLevel(vulnerabilities);

    const response: PenTestResponse = {
      report: {
        vulnerabilities,
        riskLevel,
        executionOutput: executionOutput || undefined,
        executionError: executionError || undefined
      },
      suggestions: [], // Will be filled by the suggest endpoint
      sandboxId: sandboxId || undefined,
      timestamp: new Date().toISOString()
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Pentest error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to perform security analysis',
        details: error instanceof Error ? error.message : String(error)
      },
      { status: 500 }
    );
  }
}

function getLanguageConfig(language: string): { extension: string; command: string } {
  const configs: Record<string, { extension: string; command: string }> = {
    python: { extension: 'py', command: 'python3 {file}' },
    javascript: { extension: 'js', command: 'node {file}' },
    typescript: { extension: 'ts', command: 'npx ts-node {file}' },
    bash: { extension: 'sh', command: 'bash {file}' },
    go: { extension: 'go', command: 'go run {file}' },
    java: { extension: 'java', command: 'java {file}' }
  };

  return configs[language] || configs.python;
}

